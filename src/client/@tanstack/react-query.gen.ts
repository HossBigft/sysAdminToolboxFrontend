// This file is auto-generated by @hey-api/openapi-ts

import type { OptionsLegacyParser } from '@hey-api/client-axios';
import { queryOptions, type UseMutationOptions, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { GetARecordData, GetPtrRecordData, GetZoneMasterFromDnsServersData, DeleteZoneFileForDomainData, DeleteZoneFileForDomainError, DeleteZoneFileForDomainResponse, GetMxRecordData, GetNsRecordsGoogleData, ResolveHostByDomainData, ResolveHostByIpData, GetARecordGoogleData, GetMxRecordGoogleData, GetAuthoritativeNsRecordsData, ReadUsersData, CreateUserData, CreateUserError, CreateUserResponse, DeleteUserMeError, DeleteUserMeResponse, UpdateUserMeData, UpdateUserMeError, UpdateUserMeResponse, UpdatePasswordMeData, UpdatePasswordMeError, UpdatePasswordMeResponse, RegisterUserData, RegisterUserError, RegisterUserResponse, ReadUserByIdData, UpdateUserData, UpdateUserError, UpdateUserResponse, DeleteUserData, DeleteUserError, DeleteUserResponse, GetOwnActionsData, GetOwnActionsError, GetOwnActionsResponse, GetUserActionsData, UpdateSuperuserMeData, UpdateSuperuserMeError, UpdateSuperuserMeResponse, FindPleskSubscriptionByDomainData, GetSubscriptionLoginLinkData, GetSubscriptionLoginLinkError, GetSubscriptionLoginLinkResponse, SetZonemasterData, SetZonemasterError, SetZonemasterResponse, CreateTestmailForDomainData, RecoverPasswordData, RecoverPasswordError, RecoverPasswordResponse, ResetPasswordData, ResetPasswordError, ResetPasswordResponse, RecoverPasswordHtmlContentData, RecoverPasswordHtmlContentError, RecoverPasswordHtmlContentResponse, LoginAccessTokenData, LoginAccessTokenError, LoginAccessTokenResponse, TestTokenError, TestTokenResponse } from '../types.gen';
import { client, getARecord, getPtrRecord, getZoneMasterFromDnsServers, deleteZoneFileForDomain, getMxRecord, getNsRecordsGoogle, resolveHostByDomain, resolveHostByIp, getARecordGoogle, getMxRecordGoogle, getAuthoritativeNsRecords, readUsers, createUser, readUserMe, deleteUserMe, updateUserMe, updatePasswordMe, registerUser, readUserById, updateUser, deleteUser, getOwnActions, getUserActions, updateSuperuserMe, findPleskSubscriptionByDomain, getSubscriptionLoginLink, setZonemaster, createTestmailForDomain, sharePublicKey, healthCheck, recoverPassword, resetPassword, recoverPasswordHtmlContent, loginAccessToken, testToken } from '../sdk.gen';
import type { AxiosError } from 'axios';

type QueryKey<TOptions extends OptionsLegacyParser> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends OptionsLegacyParser>(id: string, options?: TOptions, infinite?: boolean): QueryKey<TOptions>[0] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return params;
};

export const getARecordQueryKey = (options: OptionsLegacyParser<GetARecordData>) => [
    createQueryKey('getARecord', options)
];

export const getARecordOptions = (options: OptionsLegacyParser<GetARecordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getARecord({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getARecordQueryKey(options)
    });
};

export const getPtrRecordQueryKey = (options: OptionsLegacyParser<GetPtrRecordData>) => [
    createQueryKey('getPtrRecord', options)
];

export const getPtrRecordOptions = (options: OptionsLegacyParser<GetPtrRecordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPtrRecord({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPtrRecordQueryKey(options)
    });
};

export const getZoneMasterFromDnsServersQueryKey = (options: OptionsLegacyParser<GetZoneMasterFromDnsServersData>) => [
    createQueryKey('getZoneMasterFromDnsServers', options)
];

export const getZoneMasterFromDnsServersOptions = (options: OptionsLegacyParser<GetZoneMasterFromDnsServersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getZoneMasterFromDnsServers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getZoneMasterFromDnsServersQueryKey(options)
    });
};

export const deleteZoneFileForDomainMutation = (options?: Partial<OptionsLegacyParser<DeleteZoneFileForDomainData>>) => {
    const mutationOptions: UseMutationOptions<DeleteZoneFileForDomainResponse, AxiosError<DeleteZoneFileForDomainError>, OptionsLegacyParser<DeleteZoneFileForDomainData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteZoneFileForDomain({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMxRecordQueryKey = (options: OptionsLegacyParser<GetMxRecordData>) => [
    createQueryKey('getMxRecord', options)
];

export const getMxRecordOptions = (options: OptionsLegacyParser<GetMxRecordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMxRecord({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMxRecordQueryKey(options)
    });
};

export const getNsRecordsGoogleQueryKey = (options: OptionsLegacyParser<GetNsRecordsGoogleData>) => [
    createQueryKey('getNsRecordsGoogle', options)
];

export const getNsRecordsGoogleOptions = (options: OptionsLegacyParser<GetNsRecordsGoogleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNsRecordsGoogle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNsRecordsGoogleQueryKey(options)
    });
};

export const resolveHostByDomainQueryKey = (options: OptionsLegacyParser<ResolveHostByDomainData>) => [
    createQueryKey('resolveHostByDomain', options)
];

export const resolveHostByDomainOptions = (options: OptionsLegacyParser<ResolveHostByDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveHostByDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveHostByDomainQueryKey(options)
    });
};

export const resolveHostByIpQueryKey = (options: OptionsLegacyParser<ResolveHostByIpData>) => [
    createQueryKey('resolveHostByIp', options)
];

export const resolveHostByIpOptions = (options: OptionsLegacyParser<ResolveHostByIpData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveHostByIp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveHostByIpQueryKey(options)
    });
};

export const getARecordGoogleQueryKey = (options: OptionsLegacyParser<GetARecordGoogleData>) => [
    createQueryKey('getARecordGoogle', options)
];

export const getARecordGoogleOptions = (options: OptionsLegacyParser<GetARecordGoogleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getARecordGoogle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getARecordGoogleQueryKey(options)
    });
};

export const getMxRecordGoogleQueryKey = (options: OptionsLegacyParser<GetMxRecordGoogleData>) => [
    createQueryKey('getMxRecordGoogle', options)
];

export const getMxRecordGoogleOptions = (options: OptionsLegacyParser<GetMxRecordGoogleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMxRecordGoogle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMxRecordGoogleQueryKey(options)
    });
};

export const getAuthoritativeNsRecordsQueryKey = (options: OptionsLegacyParser<GetAuthoritativeNsRecordsData>) => [
    createQueryKey('getAuthoritativeNsRecords', options)
];

export const getAuthoritativeNsRecordsOptions = (options: OptionsLegacyParser<GetAuthoritativeNsRecordsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuthoritativeNsRecords({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthoritativeNsRecordsQueryKey(options)
    });
};

export const readUsersQueryKey = (options?: OptionsLegacyParser<ReadUsersData>) => [
    createQueryKey('readUsers', options)
];

export const readUsersOptions = (options?: OptionsLegacyParser<ReadUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUsersQueryKey(options)
    });
};

export const createUserQueryKey = (options: OptionsLegacyParser<CreateUserData>) => [
    createQueryKey('createUser', options)
];

export const createUserOptions = (options: OptionsLegacyParser<CreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createUserQueryKey(options)
    });
};

export const createUserMutation = (options?: Partial<OptionsLegacyParser<CreateUserData>>) => {
    const mutationOptions: UseMutationOptions<CreateUserResponse, AxiosError<CreateUserError>, OptionsLegacyParser<CreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUserMeQueryKey = (options?: OptionsLegacyParser) => [
    createQueryKey('readUserMe', options)
];

export const readUserMeOptions = (options?: OptionsLegacyParser) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUserMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUserMeQueryKey(options)
    });
};

export const deleteUserMeMutation = (options?: Partial<OptionsLegacyParser>) => {
    const mutationOptions: UseMutationOptions<DeleteUserMeResponse, AxiosError<DeleteUserMeError>, OptionsLegacyParser> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateUserMeMutation = (options?: Partial<OptionsLegacyParser<UpdateUserMeData>>) => {
    const mutationOptions: UseMutationOptions<UpdateUserMeResponse, AxiosError<UpdateUserMeError>, OptionsLegacyParser<UpdateUserMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updatePasswordMeMutation = (options?: Partial<OptionsLegacyParser<UpdatePasswordMeData>>) => {
    const mutationOptions: UseMutationOptions<UpdatePasswordMeResponse, AxiosError<UpdatePasswordMeError>, OptionsLegacyParser<UpdatePasswordMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePasswordMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerUserQueryKey = (options: OptionsLegacyParser<RegisterUserData>) => [
    createQueryKey('registerUser', options)
];

export const registerUserOptions = (options: OptionsLegacyParser<RegisterUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await registerUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerUserQueryKey(options)
    });
};

export const registerUserMutation = (options?: Partial<OptionsLegacyParser<RegisterUserData>>) => {
    const mutationOptions: UseMutationOptions<RegisterUserResponse, AxiosError<RegisterUserError>, OptionsLegacyParser<RegisterUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await registerUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUserByIdQueryKey = (options: OptionsLegacyParser<ReadUserByIdData>) => [
    createQueryKey('readUserById', options)
];

export const readUserByIdOptions = (options: OptionsLegacyParser<ReadUserByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUserById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUserByIdQueryKey(options)
    });
};

export const updateUserMutation = (options?: Partial<OptionsLegacyParser<UpdateUserData>>) => {
    const mutationOptions: UseMutationOptions<UpdateUserResponse, AxiosError<UpdateUserError>, OptionsLegacyParser<UpdateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteUserMutation = (options?: Partial<OptionsLegacyParser<DeleteUserData>>) => {
    const mutationOptions: UseMutationOptions<DeleteUserResponse, AxiosError<DeleteUserError>, OptionsLegacyParser<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOwnActionsQueryKey = (options: OptionsLegacyParser<GetOwnActionsData>) => [
    createQueryKey('getOwnActions', options)
];

export const getOwnActionsOptions = (options: OptionsLegacyParser<GetOwnActionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnActions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnActionsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<OptionsLegacyParser>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<OptionsLegacyParser>, page: K) => {
    const params = queryKey[0];
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path,
            ...page.path
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query,
            ...page.query
        };
    }
    return params as unknown as typeof page;
};

export const getOwnActionsInfiniteQueryKey = (options: OptionsLegacyParser<GetOwnActionsData>): QueryKey<OptionsLegacyParser<GetOwnActionsData>> => [
    createQueryKey('getOwnActions', options, true)
];

export const getOwnActionsInfiniteOptions = (options: OptionsLegacyParser<GetOwnActionsData>) => {
    return infiniteQueryOptions<GetOwnActionsResponse, AxiosError<GetOwnActionsError>, InfiniteData<GetOwnActionsResponse>, QueryKey<OptionsLegacyParser<GetOwnActionsData>>, number | Pick<QueryKey<OptionsLegacyParser<GetOwnActionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<OptionsLegacyParser<GetOwnActionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                body: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getOwnActions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnActionsInfiniteQueryKey(options)
    });
};

export const getOwnActionsMutation = (options?: Partial<OptionsLegacyParser<GetOwnActionsData>>) => {
    const mutationOptions: UseMutationOptions<GetOwnActionsResponse, AxiosError<GetOwnActionsError>, OptionsLegacyParser<GetOwnActionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getOwnActions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserActionsQueryKey = (options: OptionsLegacyParser<GetUserActionsData>) => [
    createQueryKey('getUserActions', options)
];

export const getUserActionsOptions = (options: OptionsLegacyParser<GetUserActionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserActions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserActionsQueryKey(options)
    });
};

export const updateSuperuserMeMutation = (options?: Partial<OptionsLegacyParser<UpdateSuperuserMeData>>) => {
    const mutationOptions: UseMutationOptions<UpdateSuperuserMeResponse, AxiosError<UpdateSuperuserMeError>, OptionsLegacyParser<UpdateSuperuserMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSuperuserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findPleskSubscriptionByDomainQueryKey = (options: OptionsLegacyParser<FindPleskSubscriptionByDomainData>) => [
    createQueryKey('findPleskSubscriptionByDomain', options)
];

export const findPleskSubscriptionByDomainOptions = (options: OptionsLegacyParser<FindPleskSubscriptionByDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findPleskSubscriptionByDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findPleskSubscriptionByDomainQueryKey(options)
    });
};

export const getSubscriptionLoginLinkQueryKey = (options: OptionsLegacyParser<GetSubscriptionLoginLinkData>) => [
    createQueryKey('getSubscriptionLoginLink', options)
];

export const getSubscriptionLoginLinkOptions = (options: OptionsLegacyParser<GetSubscriptionLoginLinkData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubscriptionLoginLink({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubscriptionLoginLinkQueryKey(options)
    });
};

export const getSubscriptionLoginLinkMutation = (options?: Partial<OptionsLegacyParser<GetSubscriptionLoginLinkData>>) => {
    const mutationOptions: UseMutationOptions<GetSubscriptionLoginLinkResponse, AxiosError<GetSubscriptionLoginLinkError>, OptionsLegacyParser<GetSubscriptionLoginLinkData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getSubscriptionLoginLink({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const setZonemasterQueryKey = (options: OptionsLegacyParser<SetZonemasterData>) => [
    createQueryKey('setZonemaster', options)
];

export const setZonemasterOptions = (options: OptionsLegacyParser<SetZonemasterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setZonemaster({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setZonemasterQueryKey(options)
    });
};

export const setZonemasterMutation = (options?: Partial<OptionsLegacyParser<SetZonemasterData>>) => {
    const mutationOptions: UseMutationOptions<SetZonemasterResponse, AxiosError<SetZonemasterError>, OptionsLegacyParser<SetZonemasterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setZonemaster({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createTestmailForDomainQueryKey = (options: OptionsLegacyParser<CreateTestmailForDomainData>) => [
    createQueryKey('createTestmailForDomain', options)
];

export const createTestmailForDomainOptions = (options: OptionsLegacyParser<CreateTestmailForDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTestmailForDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTestmailForDomainQueryKey(options)
    });
};

export const sharePublicKeyQueryKey = (options?: OptionsLegacyParser) => [
    createQueryKey('sharePublicKey', options)
];

export const sharePublicKeyOptions = (options?: OptionsLegacyParser) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sharePublicKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sharePublicKeyQueryKey(options)
    });
};

export const healthCheckQueryKey = (options?: OptionsLegacyParser) => [
    createQueryKey('healthCheck', options)
];

export const healthCheckOptions = (options?: OptionsLegacyParser) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await healthCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: healthCheckQueryKey(options)
    });
};

export const recoverPasswordQueryKey = (options: OptionsLegacyParser<RecoverPasswordData>) => [
    createQueryKey('recoverPassword', options)
];

export const recoverPasswordOptions = (options: OptionsLegacyParser<RecoverPasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recoverPassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recoverPasswordQueryKey(options)
    });
};

export const recoverPasswordMutation = (options?: Partial<OptionsLegacyParser<RecoverPasswordData>>) => {
    const mutationOptions: UseMutationOptions<RecoverPasswordResponse, AxiosError<RecoverPasswordError>, OptionsLegacyParser<RecoverPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await recoverPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resetPasswordQueryKey = (options: OptionsLegacyParser<ResetPasswordData>) => [
    createQueryKey('resetPassword', options)
];

export const resetPasswordOptions = (options: OptionsLegacyParser<ResetPasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resetPassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resetPasswordQueryKey(options)
    });
};

export const resetPasswordMutation = (options?: Partial<OptionsLegacyParser<ResetPasswordData>>) => {
    const mutationOptions: UseMutationOptions<ResetPasswordResponse, AxiosError<ResetPasswordError>, OptionsLegacyParser<ResetPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const recoverPasswordHtmlContentQueryKey = (options: OptionsLegacyParser<RecoverPasswordHtmlContentData>) => [
    createQueryKey('recoverPasswordHtmlContent', options)
];

export const recoverPasswordHtmlContentOptions = (options: OptionsLegacyParser<RecoverPasswordHtmlContentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recoverPasswordHtmlContent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recoverPasswordHtmlContentQueryKey(options)
    });
};

export const recoverPasswordHtmlContentMutation = (options?: Partial<OptionsLegacyParser<RecoverPasswordHtmlContentData>>) => {
    const mutationOptions: UseMutationOptions<RecoverPasswordHtmlContentResponse, AxiosError<RecoverPasswordHtmlContentError>, OptionsLegacyParser<RecoverPasswordHtmlContentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await recoverPasswordHtmlContent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginAccessTokenQueryKey = (options: OptionsLegacyParser<LoginAccessTokenData>) => [
    createQueryKey('loginAccessToken', options)
];

export const loginAccessTokenOptions = (options: OptionsLegacyParser<LoginAccessTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await loginAccessToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginAccessTokenQueryKey(options)
    });
};

export const loginAccessTokenMutation = (options?: Partial<OptionsLegacyParser<LoginAccessTokenData>>) => {
    const mutationOptions: UseMutationOptions<LoginAccessTokenResponse, AxiosError<LoginAccessTokenError>, OptionsLegacyParser<LoginAccessTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await loginAccessToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const testTokenQueryKey = (options?: OptionsLegacyParser) => [
    createQueryKey('testToken', options)
];

export const testTokenOptions = (options?: OptionsLegacyParser) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testTokenQueryKey(options)
    });
};

export const testTokenMutation = (options?: Partial<OptionsLegacyParser>) => {
    const mutationOptions: UseMutationOptions<TestTokenResponse, AxiosError<TestTokenError>, OptionsLegacyParser> = {
        mutationFn: async (localOptions) => {
            const { data } = await testToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};